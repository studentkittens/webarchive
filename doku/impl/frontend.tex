\chapter{Frontend}

\section{Logging und Exceptionhandling}
Bei der Implementierung der Klassen wurde soweit möglich auf das Werfen von Exceptions verzichtet.
Stattdessen wird mit \lstinline{assert}-Statements gearbeitet um ungültige Eingaben, Ausgaben und Zustände schon frühzeitig während der Testphase zu erkennen. 
Diese sind dann später defaultmäßig ausgeschaltet, was die Performance verbessert.

Von Drittanbietern, bzw. der Java-Bibliothek erzeugte Exceptions werden je nach Ursache behandelt.
Interne Fehler werden geloggt und in Logfiles geschrieben. Diese befinden sich ebenfalls im installierten Archivordner.

Von Benutzern verursachte Fehler (z.B. Syntaxfehler in SQL-Klauseln) werden über einen Mechanismus
in der Server-Clientkommunikation zurückgeschickt und im Client erneut geworfen.

\section{Tests}
\subsection{ClientMockup}
	Der ClientMockup testet alle Schnittstellen zum Client, zum Backend (JavaDapter) sowie die Kommunkation übers Netzwerk.
	Dabei wird das Zusammenspiel aller Komponenten getestet.
\subsection{Unittests}
	In den Unittests wird die Funktionalität der einzelnen Klassen getestet.
	Die Tests sind packageweise in Testsuites verknüpft, welche wiederum über eine übergeordnete TestSuite aufgerufen werden können.
	Hier folgt die Erläuterung für paketweise:	
	\subsubsection{webarchive.api}
		In der API werden nur die konkreten Klassen getestet, Schnittstellen
		oder Abstraktionen werden in den konkreten Implementierungen der anderen Pakete oder im ClientMockup getestet.
		\paragraph{.model}
		Bei den Modelklassen müssen hauptsächlich Getter getestet werden.
		Außerdem werden auch illegale Eingaben in die Konstruktoren getestet,
		wobei diese nur mit asserts abgefangen werden, da Objekte später nicht
		ins System geschrieben werden können.
		\paragraph{.select}
		Die API-Selectklassen bereiten die Eingaben der Benutzer auf die
		Select-klassen im Server vor (benannte where-Parameter werden in
		eine generische Arrayform gebracht).

		Es wird deshalb getestet, ob durch Eingaben die richtige Arrayausgabeform erzeugt wird.

		Null-werte sind legal und werden als nicht vorhandene WHERE- bzw. ORDER-BY Klausel interpretiert.
		Das Erkennen von Syntaxfehlern in den Klauseln wird natürlich der Datenbank überlassen.
		\paragraph{.xml}
		Es wird die TagName-klasse getestet, welche dafür sorgt dass Xml-Tagnames mit richtigen Präfixen versehen wird. Es wird also die Erzeugung mit verschieden Eingaben und deren Ausgabe getestet.

	\subsubsection{webarchive.xml}
		Da das XML-Paket hierarchisch aufgebaut ist, sind die Tests dementsprechend gestaltet. 
		In Lowlevel-Klassen werden die Primitivfunktionen getestet, während in den Highlevel-Controllern (XmlHandler, XmlEditor) zusammengesetzte Funktionalitäten getestet werden. 

	Die Netzwerkverbindung wird dabei mit Mockupklassen umgangen. 
	Es wird auch die Konfigurierung von XmlConf mit einer Test-Configdatei geprüft.
	Desweiteren wird geprüft:
	\begin{itemize}
		\item Das Auslesen vorhandener und nicht vorhandener Datenelemente.
		\item Hinzufügen von Datenelementen, inklusive Transformation der DOM und schreiben auf die Festplatte.
		\item Die Übergabe ungültiger Werte wie null, schreibgeschützter oder bereits vorhandener DataElement-objekte, 
		\item Die Validierung: Das Anlegen von neuen Datenelementen, mit hinzugefügten gültigen Elementen in einer Test-xsd-Datei sowie das Hinzufügen invalider Elemente.
	\end{itemize}


	\subsubsection{webarchive.dbaccess}
		Die Datenbankklassen werden mithilfe einer Testdatenbank getestet, welche sich im Ordner \lstinline{test/sql} befindet.

		Bei den Typbezogenen Selects (z.B. SelectMetaDataTest) wird getestet, 
		ob das Mapping zwischen relationeller DB und Objekten funktioniert.
		Außerdem werden erwartete Testwerte aus der Datenbank abgeprüft.
		
		Die abstrakte Klasse SelectJoin wird dahingehend getestet, 
		dass vorbereite SELECT-Statements anhand der übergebenen Parameter richtig zusammengesetzt werden.
		Diese SELECTs werden dann anschließend mit verschiedenen Pseudo-WHERE- und ORDER-BY-Klauseln gefüllt
		und die Syntax geprüft.
		Desweiteren sollen SQL-injections durch interne Abfragen verhindert werden.

		Die Klasse SqlHandler, welche als Fassadenschnittstelle nach aussen dient, wird daraufhin
		geprüft, dass übergeben Select-objekte (aus dem api-package) den richtigen Ausführungsselects zugeordnet werden. Das Ergebnis kann wiederum anhand erwartbar Rückgabewerte geprüft werden.
